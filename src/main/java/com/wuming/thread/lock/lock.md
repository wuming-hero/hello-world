## 1. 乐观锁与悲观锁
### 1.1 悲观锁
悲观锁，指数据被外界修改持保守态度(悲观),在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 。
数据库中实现是对数据记录进行操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。
如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。
一个例子：`select * from 表 where .. for update;` 

悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，
另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。

### 1.2 乐观锁
乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，
具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。

乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。
乐观锁示例：`update table1 set name=#{name}, version=${version}+1 where id =#{id} and version=#{version}` 

业务上根据返回值为0就可以知道当前更新没有成功，那么接下来有两个做法，
如果业务发现更新失败就失败了，那么下面可以什么都不做，把错误抛出去让上层调用方知道更新失败了，也就是上面这种处理方式。
如果失败了需要重试保证业务强一致性，则updateEntry的代码可以修改为如下：
```java
public boolean updateEntry(long id){
    boolean result = false;
    int retryNum = 5;
    // 使用循环重试抢锁更新
    while(retryNum>=0){

        // 1.重新获取当前实例
        EntryObject entry = query("select * from table1 where id = #{id}",id);
        // 2.修改记录内容，version字段不能被修改
        entry.setName("name");
       // 3.update操作
       int count = update("update table1 set name=#{name}, version=${version}+1 where id =#{id} and version=#{version}", id, entry.getName(), entry.getVersion());
       if(count == 1){
          result = true;
          break;
       }
       retryNum--;
    }
    return result;

}
```

## 2. 独占锁与共享锁
根据锁能够被单个线程还是多个线程共同持有，锁又分为独占锁和共享锁。
独占锁保证任何时候都只有一个线程能读写权限，ReentrantLock就是以独占方式实现的互斥锁。
共享锁则可以同时有多个读线程，但最多只能有一个写线程，读和写是互斥的，例如ReadWriteLock读写锁，它允许一个资源可以被多线程同时进行读操作，或者被一个线程写操作，但两者不能同时进行。

独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。

共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。

## 3. 公平锁与非公平锁
根据线程获取锁的抢占机制锁可以分为公平锁和非公平锁，

1. 公平锁表示线程获取锁的顺序是按照线程加锁的时间多少来分决定的的，也就是最早加锁的线程将最早获取锁，也就是先来先得的FIFO顺序。
2. 非公平锁则运行闯入，也就是先来不一定先得。

ReentrantLock提供了公平和非公平锁的实现：
公平锁 `ReentrantLock pairLock = new ReentrantLock(true);` 
非公平锁 `ReentrantLock pairLock = new ReentrantLock(false);` 

如果构造函数不传递参数，则默认是`非公平锁`。

注：在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。

假设线程A已经持有了锁，这时候线程B请求该锁将会被挂起，当线程A释放锁后，假如当前有线程C也需要获取该锁，
如果采用非公平锁方式，则根据线程调度策略线程B和C两者之一可能获取锁，这时候不需要任何其他干涉，
如果使用公平锁则需要把C挂起，让B获取当前锁。


公平与非公平都是先执行tryAcquire尝试获取锁，如果成功则直接获取锁，如果不成功则把当前线程放入队列。
对于放入队列里面的第一个线程A在`unpark`后会进行自旋调用`tryAcquire` 尝试获取锁，假如这时候有一个线程B执行了lock操作，那么也会调用tryAcquire方法尝试获取锁，但是线程B并不在队列里面，但是线程B有可能比线程A优先获取到锁，也就是说虽然线程A先请求的锁，但是却有可能没有B先获取锁，这是非公平锁实现。
而公平锁要保证线程A要比线程B先获取锁。所以公平锁相比非公平锁在tryAcquire里面添加了`hasQueuedPredecessors` 方法用来保证公平性。
