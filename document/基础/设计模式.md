
面向对象设计原则
设计模式需要遵从以下几个原则：
1. 单一职责原则：每个类都应该有一个单一的职责，只负责一项任务。
2. 开放封闭原则：系统应该对扩展开放，对修改关闭，也就是说，应该通过扩展已有类或添加新类的方式来实现功能的更新，而不是修改既有类的代码。
3. 里氏替换原则：所有引用基类的地方必须能够透明地使用其子类对象，也就是说，子类对象可以替换父类对象出现在任何地方，并且不会影响程序的正确性。
4. 依赖倒置原则：高层模块不应该依赖底层模块，它们应该依赖于抽象，也就是说，应该通过接口或抽象类来定义模块之间的依赖关系，而不是通过具体的实现类来定义。
5. 接口隔离原则：客户端不应该依赖它不需要的接口，也就是说，应该将接口细分，使得每个类只依赖于它需要的接口。
6. 迪米特法则：一个对象应该对其他对象有尽可能少的了解，也就是说，对象之间的耦合应该尽量少，只关注自己需要的对象。
   遵循这些原则可以使得代码更加可读、可维护和可扩展，同时也能够提高代码的质量和重用性。
   
## 策略模式
在JDK中，Comparator接口就是策略模式的典型应用。Comparator接口是用来定义两个对象之间的比较规则的，在Java中，很多数据结构都依赖于Comparator接口来进行排序操作。
以下是JDK中Comparator接口的简单实现：
```java
public interface Comparator<T> {
    public int compare(T o1, T o2);
}
```
在这个实现中，Comparator接口只有一个compare()方法，用于比较两个对象的大小关系。在实际应用中，我们可以根据具体的需求，来实现不同的Comparator对象，从而实现不同的比较规则。
例如，对于一个存放Person对象的集合，我们可以根据Person对象的不同属性来创建不同的Comparator对象，例如按照年龄、身高、姓名等来排序。下面是按照年龄大小来排序的Comparator实现：
```java
public class PersonAgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person o1, Person o2) {
        return o1.getAge() - o2.getAge();
    }
}
```
在这个实现中，PersonAgeComparator实现了Comparator接口，并重写了compare()方法，根据Person对象的年龄属性来比较两个对象的大小关系。
JDK中的Comparator接口是策略模式的典型应用，它使得我们可以根据不同的需求来创建不同的比较规则，提高了程序的灵活性和可扩展性。


https://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html