面向对象设计原则
设计模式需要遵从以下几个原则：
1. 单一职责原则：每个类都应该有一个单一的职责，只负责一项任务。
2. 开放封闭原则：系统应该对扩展开放，对修改关闭，也就是说，应该通过扩展已有类或添加新类的方式来实现功能的更新，而不是修改既有类的代码。
3. 里氏替换原则：所有引用基类的地方必须能够透明地使用其子类对象，也就是说，子类对象可以替换父类对象出现在任何地方，并且不会影响程序的正确性。
4. 依赖倒置原则：高层模块不应该依赖底层模块，它们应该依赖于抽象，也就是说，应该通过接口或抽象类来定义模块之间的依赖关系，而不是通过具体的实现类来定义。
5. 接口隔离原则：客户端不应该依赖它不需要的接口，也就是说，应该将接口细分，使得每个类只依赖于它需要的接口。
6. 迪米特法则：一个对象应该对其他对象有尽可能少的了解，也就是说，对象之间的耦合应该尽量少，只关注自己需要的对象。
   遵循这些原则可以使得代码更加可读、可维护和可扩展，同时也能够提高代码的质量和重用性。


设计模式按照使用场景可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
* 1.创建型模式（Creational Patterns）
对对象的实例化过程进行抽象，这使得一个系统可以不用关心这些对象是如何创建，组合，呈现的，对于类创建模式来说通过使用继承改变实例化的类，对于对象创建模式来说通过使用代理来实例化所需要的对象。

* 2.结构型模式（Structural Patterns）
通过对多个类和对象进行组合得到复杂结构的类，一般使用继承继承或者成员变量引用形式来实现。

* 3.行为型模式（Behavioral Patterns）
行为模式不仅表达了对象和类，还表达了他们之间的交互，涉及到了对象和算法的分配。

# 创建模式
## 单例模式
## 原型模式
## 工厂模式
## 构建者模式

# 结构型模式

## 装饰者模式
## 适配器模式
## 桥接模式
## 代理模式
## 过滤器模式
## 门面模式
## 组合模式
## 享元模式


# 行为型模式
## 策略模式
在JDK中，Comparator接口就是策略模式的典型应用。Comparator接口是用来定义两个对象之间的比较规则的，在Java中，很多数据结构都依赖于Comparator接口来进行排序操作。
以下是JDK中Comparator接口的简单实现：
```java
public interface Comparator<T> {
    public int compare(T o1, T o2);
}
```
在这个实现中，Comparator接口只有一个compare()方法，用于比较两个对象的大小关系。在实际应用中，我们可以根据具体的需求，来实现不同的Comparator对象，从而实现不同的比较规则。
例如，对于一个存放Person对象的集合，我们可以根据Person对象的不同属性来创建不同的Comparator对象，例如按照年龄、身高、姓名等来排序。下面是按照年龄大小来排序的Comparator实现：
```java
public class PersonAgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person o1, Person o2) {
        return o1.getAge() - o2.getAge();
    }
}
```
在这个实现中，PersonAgeComparator实现了Comparator接口，并重写了compare()方法，根据Person对象的年龄属性来比较两个对象的大小关系。
JDK中的Comparator接口是策略模式的典型应用，它使得我们可以根据不同的需求来创建不同的比较规则，提高了程序的灵活性和可扩展性。
## 责任链模式
## 观察者模式
## 解释器模式
## 迭代器模式
## 命令模式
## 状态模式
## 模板模式
## 访问者模式
## 中介者模式
## 空对象模式
## 备忘录模式

https://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html