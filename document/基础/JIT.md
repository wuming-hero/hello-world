# Java 中的 JIT（Just-In-Time）编译器
## 1. JIT 的定义
JIT（Just-In-Time）编译器是一种用于 Java 虚拟机（JVM）的动态编译技术。
它在 Java 程序运行时，将 Java 字节码（Bytecode）转换为本地机器代码，从而提高程序的运行效率。

* 位置：JIT 是 JVM 的一部分，内嵌在 JVM 内部。
* 目标：提升字节码执行的速度，接近本地代码的性能。

## 2. JIT 编译器的工作原理

### 2.1 JVM 的初始执行方式
Java 是通过解释器（Interpreter）来逐行解释执行字节码的。这种方式简单灵活，但效率较低，因为每次运行都需要解释字节码。

### 2.2 JIT 的介入
当 JVM 发现某些代码被多次执行时，JIT 编译器会将这些热点代码（Hotspot Code）编译为机器码，并将其缓存。之后运行时直接执行这些本地代码，而不再解释，从而显著提高性能。

## 3. JIT 的执行过程
JIT 的执行过程可以分为以下几个阶段：

1. 字节码加载：
Java 类被加载到 JVM 中，并以字节码的形式存储。

2. 热点检测：
JVM 使用统计信息找到执行频率较高的热点代码。

3. 即时编译：
热点代码由 JIT 编译器编译为本地机器代码。

4. 缓存与执行：
编译后的机器代码被缓存，后续直接执行，避免了重复解释。
   
## 4. JIT 的优化技术
JIT 编译器使用多种优化技术来提升性能：

1. 方法内联（Method Inlining）：
将小方法的代码直接嵌入调用点，减少方法调用的开销。

2. 循环优化（Loop Optimization）：
对循环体进行展开、合并或消除等优化，减少循环开销。

3. 死代码消除（Dead Code Elimination）：
移除不会被执行的代码，精简代码逻辑。

4. 常量折叠（Constant Folding）：
编译期间计算出常量表达式的结果，避免运行时计算。

5. 逃逸分析（Escape Analysis）：
判断对象是否只在方法内部使用，如果是，则分配到栈中，而非堆中，减少 GC 压力。
   
## 5. JIT 的分类
JVM 中的 JIT 编译器通常分为以下两种类型：

1. C1 编译器（Client Compiler）：
面向客户端应用，启动速度快，优化力度相对较低。

2. C2 编译器（Server Compiler）：
面向服务器端应用，优化力度高，适用于长时间运行的程序。

## 6. JIT 的优缺点
### 6.1 优点：
* 高性能：
热点代码编译为本地代码后执行速度接近本地程序。

* 动态优化：
JIT 根据运行时信息进行优化，能够针对实际使用情况提升性能。

* 灵活性：
兼顾解释执行和编译执行的优点，适应多种运行环境。

### 6.2 缺点：
* 首次运行性能较低：
热点代码在被编译前仍需解释执行。

* 额外的内存开销：
编译的机器代码需要占用额外的内存。
   
* 复杂性增加：
JIT 编译器的优化需要复杂的算法和更多的资源。

## 7. JIT 的示例
   以下是一个示例，用来展示 JIT 编译对性能的影响：
```java
public class JITExample {
    public static void main(String[] args) {
        long start = System.nanoTime();
        for (int i = 0; i < 1_000_000_000; i++) {
            calculate();
        }
        long end = System.nanoTime();
        System.out.println("Execution Time: " + (end - start) / 1_000_000.0 + " ms");
    }

    private static int calculate() {
        return 42; // 热点代码
    }
}
```

解释：
* 方法 calculate() 会被频繁调用，成为热点代码。
* 在程序运行初期，calculate() 会由解释器逐行执行。
* 当 JIT 检测到其是热点代码后，会将其编译为机器码，运行效率显著提高。

## 8. 总结
* JIT 是 JVM 中的动态编译器，在运行时将热点代码编译为本地机器代码，提升程序性能。
* JIT 与解释器配合使用，结合了动态性和高效性。
* 优化技术：包括方法内联、循环优化、逃逸分析等，使编译后的代码性能更高。
* 分类：C1 编译器适用于客户端，C2 编译器适用于服务器。
* 缺点：首次运行性能较低，增加了内存开销，但总体性能收益显著。


https://www.cnblogs.com/eiffelzero/p/18598203