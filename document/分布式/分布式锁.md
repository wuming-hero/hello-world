# 分布式锁
## redis分布式锁如何实现？ 底层算法和数据结构是什么样？

Redis的分布式锁是通过Redis的原子性操作来实现的，主要使用了Redis的SET命令以及SETNX（Set if Not eXists）、GETSET等命令。下面我将详细解释这些命令是如何工作的，以及它们背后的算法和数据结构。

### 1. 使用SETNX命令

SETNX命令用于设置一个键的值，如果这个键不存在。如果键已经存在，则不执行任何操作。这个命令是实现分布式锁的基础。

命令格式：
```bash
SETNX key value
```

返回值：

返回1，表示键不存在，设置成功。

返回0，表示键已存在，设置失败。


使用示例：
```bash
SETNX lock_key "my_lock_value"
```

### 2. 使用SET命令与EX和NX选项

虽然SETNX是实现分布式锁的基础，但在实际应用中，我们更倾向于使用SET命令结合EX（过期时间）和NX（仅当键不存在时设置）选项。这样可以更安全地实现锁。

命令格式：
```bash
SET key value [EX seconds] [PX milliseconds] [NX|XX]
```

示例：
```bash
SET lock_key "my_lock_value" NX EX 10
```

这条命令设置了键lock_key的值为"my_lock_value"，仅当键不存在时设置，并且设置过期时间为10秒。

### 3. 实现分布式锁的算法步骤

尝试获取锁： 使用SET命令尝试获取锁，如果返回1，表示成功获取锁；如果返回0，表示锁已被其他客户端获取。

设置过期时间： 为了避免死锁（即客户端获取锁后崩溃或长时间未释放），在获取锁时设置一个过期时间。

释放锁： 使用DEL命令释放锁。或者使用Lua脚本在客户端执行释放操作，确保操作的原子性。

### 4. 使用Lua脚本增强安全性

为了更安全地释放锁，可以使用Lua脚本。这样可以确保在获取锁和释放锁的过程中，即使在网络分区或其他并发情况下也不会出错。

Lua脚本示例：
```bash
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```

这里，KEYS[1]是锁的键，ARGV[1]是持有锁的值。
只有当当前客户端持有的值与Redis中存储的值相匹配时，才会删除该键，从而释放锁。

### 5. 数据结构

在Redis中，分布式锁的实现依赖于简单的字符串类型（String）。
Redis使用哈希表来实现这些字符串的存储和访问，这使得操作非常快速且高效。

通过组合使用Redis的原子性操作和Lua脚本，我们可以实现一个高效且安全的分布式锁机制。这种方式不仅保证了锁的正确性，还通过设置过期时间避免了死锁的风险。

## zookeeper 分布式锁

### 实现原理

Zookeeper利用其树形结构和临时有序节点特性实现分布式锁。客户端在Zookeeper的指定节点下创建一个临时有序节点，然后获取该节点下所有子节点并排序。若自己创建的节点序号最小，则获取锁成功；否则，对前一个序号的节点注册Watcher监听。当前一个节点被删除时，Zookeeper会通知该客户端，客户端再次检查自己是否为最小节点，以决定是否获取锁。例如在Java中，使用Curator框架实现获取锁的代码如下：
```java
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.apache.curator.retry.RetryNTimes;

public class ZookeeperLock {
private static final String ZK_ADDRESS = "localhost:2181";
private static final String LOCK_PATH = "/my_distributed_lock";

    public static void main(String[] args) throws Exception {
        CuratorFramework client = CuratorFrameworkFactory.newClient(ZK_ADDRESS, new RetryNTimes(3, 1000));
        client.start();

        InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH);
        if (lock.acquire(5, java.util.concurrent.TimeUnit.SECONDS)) {
            try {
                // 获取锁成功，执行业务逻辑
            } finally {
                lock.release();
            }
        }
        client.close();
    }
}
```

### 优势
1. 强一致性：Zookeeper采用ZAB（Zookeeper Atomic Broadcast）协议保证数据的强一致性，即使在部分节点故障或网络波动的情况下，也能确保分布式锁的正确性和可靠性。
2. 高可用性：通过多节点的选举机制和数据复制，Zookeeper具备良好的容错能力，单个节点故障不会影响整个锁服务的可用性。
3. 天然的监听机制：Watcher机制能实时感知节点状态变化，在锁的获取与释放过程中提供高效的通知机制，减少不必要的轮询操作。

### 不足
1. 性能相对较低：由于Zookeeper的写操作需要在多个节点间进行数据同步，其性能相比基于内存操作的Redis略逊一筹，尤其在高并发写场景下，响应时间可能较长。
2. 实现复杂度较高：基于Zookeeper实现分布式锁涉及到节点创建、排序、监听等多个复杂操作，需要开发者深入理解Zookeeper的原理和机制，增加了开发难度和维护成本。

## 四、Redis与Zookeeper分布式锁的综合对比
* 一致性:  在集群环境下存在脑裂风险，一致性保障相对较弱 采用ZAB协议，具有强一致性
* 性能:  基于内存操作，读写速度快，性能高 写操作需多节点同步，性能相对较低
* 可用性： 依赖主从复制和哨兵机制，可用性较高，但脑裂时可能短暂影响 多节点选举和数据复制，高可用性，单个节点故障不影响
* 实现复杂度：实现简单，基于基本命令 实现复杂，涉及节点管理、监听等复杂操作
* 应用场景： 适用于对性能要求极高，对一致性要求相对较低的高并发读多写少场景，如缓存更新控制 适用于对数据一致性和可靠性要求极高，对性能要求可接受一定延迟的场景，如分布式事务协调

## 五、总结与建议
Redis和Zookeeper实现的分布式锁各有优劣，在实际应用中，开发者应根据项目的具体需求进行权衡选择。

若系统追求极致性能，且对数据一致性的短暂偏差有一定容忍度，Redis分布式锁是理想之选；

若系统对数据一致性和可靠性要求严苛，即使牺牲部分性能也在所不惜，Zookeeper分布式锁无疑是更合适的方案。

在技术选型过程中，还需综合考虑系统架构、业务场景、运维成本等多方面因素，确保所选的分布式锁实现方式能够为整个分布式系统的稳定运行和高效发展提供坚实支撑。


https://blog.csdn.net/hanyu5201314/article/details/147078001