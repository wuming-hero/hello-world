## mysql索引类型

### 聚簇索引 (Clustered Index):
* 定义： 表数据行的物理存储顺序与索引键（通常就是主键）的顺序一致。叶子节点直接存储完整的行数据。
* 唯一性： 每个表有且只有一个聚簇索引。
* 创建规则：
  * 如果定义了主键（PRIMARY KEY），则该主键自动成为聚簇索引。
  * 如果没有显式定义主键，则InnoDB会选择第一个定义的不允许NULL值的唯一索引（UNIQUE NOT NULL）作为聚簇索引。
  * 如果以上都没有，则InnoDB会隐式创建一个名为GEN_CLUST_INDEX的隐藏ROWID列（6字节）作为聚簇索引。
* 特点： 通过聚簇索引查找数据最快（一步到位）。主键的顺序影响数据插入的位置和新页的分裂。

### 二级索引 (Secondary Index, 辅助索引)：
* 定义： 除了聚簇索引以外的所有索引，都称为二级索引。
* 存储内容： 二级索引的叶子节点存储的是该索引的键值 + 对应行的聚簇索引键值（即主键值，或者ROWID），而不是完整的数据行。
* 查找过程： 通过二级索引找到目标记录后，还需要使用该记录的主键值（或ROWID）回到聚簇索引中进行一次查找（称为“回表”（Bookmark Lookup / Key Lookup）才能获取完整的数据行。
* 数量： 一张表可以有零个或多个二级索引。

#### 常见类型：
* 单列索引 (Single-Column Index)： 基于单个列创建的索引（如 INDEX idx_name (last_name)）。
* 复合索引 (Composite Index, 联合索引 - Multi-Column Index)： 本质上是二级索引的一种子类。基于多个列组合创建的索引（如 INDEX idx_name_age (last_name, age)）。
* 前缀索引 (Prefix Index)： 对字符串列的前N个字符创建的索引（如 INDEX idx_email (email(10))）, 本质上是特殊的单列/复合索引。
* 唯一索引 (Unique Index)： 可以是单列或复合索引，要求索引键值唯一（允许多个NULL值，视数据库NULL处理而定）。除了保证唯一性，也提供查询优化功能（加速）。
* 覆盖索引 (Covering Index)： 不是一种新的索引结构，而是指一个查询的性能优化状态。如果一个查询所需的所有列都包含在一个二级索引的键值中（包括叶子节点中的主键值），那么查询过程只需要访问该二级索引的B+树，而不用回表（避免了磁盘I/O），这个二级索引就称为该查询的覆盖索引（Covering Index）。

#### 覆盖索引 (Covering Index)
> 覆盖索引不是一种新的索引结构，而是指一个查询的性能优化状态。 
> 如果一个查询所需的所有列都包含在一个二级索引的键值中（包括叶子节点中的主键值），那么查询过程只需要访问该二级索引的B+树，而不用回表（避免了磁盘I/O），这个二级索引就称为该查询的覆盖索引（Covering Index）。

##### 场景设定
1. 表结构： user表
```sql
id(INT, PRIMARY KEY) -- 主键，聚簇索引的键
name(VARCHAR(100))
age(INT)
city(VARCHAR(50))
email(VARCHAR(100))
```
2. 存在索引：
* 聚簇索引 (Clustered Index)： 自动建立在 id列上。叶子节点存储完整的 user表记录 (id, name, age, city, email)。
* 二级索引： INDEX idx_nc (name, city)。这是一个复合索引，包含 name和 city两列。

##### 情况一：非覆盖索引查询（需要回表）
查询需要的列： name, city(用于过滤WHERE条件) + email, age(用于SELECT结果)。
```mysql
SELECT email, age FROM user WHERE name = 'Alice' AND city = 'New York';
```

执行步骤：

1. 访问二级索引 idx_nc：
  * 在 idx_nc的B+树中，根据 WHERE name = 'Alice' AND city = 'New York'进行查找。
  * 定位到 idx_nc叶子节点中满足条件的条目。
  * 关键点： idx_nc叶子节点存储的内容是：(name, city)的值 + 对应的主键值 id。
  * 所以，在这个步骤结束后，引擎获得了满足条件的 (name='Alice', city='New York', id=X)组合（假设找到的id值是X）。但它没有 email或 age的值。
2. 回表操作 (Bookmark Lookup)：
  * 使用步骤1中获得的每条记录的 id值 (X)，去聚簇索引的B+树中进行查找。
  * 在聚簇索引中根据 id=X定位到对应的叶子节点。
  * 从聚簇索引的叶子节点中读取该记录的完整数据行：(id=X, name, age, city, email)。
3. 提取所需数据：
* 从聚簇索引读到的完整行数据中，提取出查询需要的 email和 age的值。 
4. 返回结果：
* 将结果 (email, age)返回给客户端。问题： 这个“使用id去聚簇索引取数据”的步骤2就是回表。它需要额外的磁盘I/O（如果数据页不在内存中），消耗额外的CPU和内存资源来处理索引树的遍历和数据读取。如果查询匹配了1000条记录，就需要执行1000次回表操作，性能开销巨大。

##### 情况二：覆盖索引查询（避免回表）
查询需要的列： name, city(既是WHERE条件，也是SELECT结果列) + id(隐含的WHERE匹配需要)。
```mysql
SELECT name, city FROM user WHERE name = 'Alice' AND city = 'New York';
```

执行步骤：

1. 访问二级索引 idx_nc：
* 在 idx_nc的B+树中，根据 WHERE name = 'Alice' AND city = 'New York'进行查找。
* 定位到 idx_nc叶子节点中满足条件的条目。
* 关键点： idx_nc叶子节点存储的内容正是：(name, city)的值 + 对应的主键值 id。
* 查询需要的 name, city的值已经直接包含在二级索引 idx_nc的叶子节点里了！ id值也在这里，但对于返回结果不是必须的（除非SELECT需要）。
2. 提取所需数据：
* 直接从 idx_nc当前扫描到的叶子节点条目中，读取 name和 city的值。
3. 返回结果：
* 将结果 (name, city)返回给客户端。核心优势： 步骤2直接从二级索引叶子节点拿到了所有需要返回的数据 (name, city)。完全跳过了 “使用id去聚簇索引取完整数据行”的回表步骤。


##### 覆盖索引避免回表的原理总结
1. 存储内容的完备性： 一个二级索引（无论是单列索引还是复合索引）的叶子节点存储的不是指向数据行的物理地址指针，而是存储了：
  * 该索引定义的所有列的值（例如idx_nc包含name, city）。
  * 对应行的主键值 (id)。
2. 查询需求的满足： 
如果一条 SQL 查询语句所需的所有列（包括 SELECT 的目标列、WHERE/JOIN/GROUP BY/ORDER BY 涉及的列），都恰好包含在一个二级索引的存储内容中（即要么是该索引包含的列，要么是它存储的主键），那么：
  * 数据库引擎在执行这条查询时，只需要访问该二级索引的 B+ 树一次。
  * 在扫描该二级索引的叶子节点（满足过滤条件后）时，就能直接获取到查询需要的所有数据值。
3. 跳过物理数据访问： 
由于需要的所有数据都已经存在于二级索引的叶子节点记录中，数据库引擎就没有必要再拿着主键值 id去昂贵的聚簇索引树中进行第二次查找（即回表）来获取整行数据了。从而节省了大量的磁盘I/O（尤其是随机I/O）和CPU资源。
4. 性能关键： 避免回表带来的性能提升是显著的，因为：
  * 聚簇索引通常远大于二级索引（存储完整行数据 vs 存储索引列+主键）。
  * 二级索引的结构通常更紧凑，扫描范围更小。
  * 随机访问聚簇索引（回表）的I/O成本非常高。

##### 如何判断一个查询使用了覆盖索引？
  在 MySQL 的 EXPLAIN命令输出中，当 Extra列出现 `Using index`  时，表示该查询使用了覆盖索引优化。

##### 重要补充
* 主键是隐性覆盖： 
因为所有二级索引的叶子节点都存储了主键值，所以 SELECT id FROM ... WHERE ...(索引条件) 或 SELECT 某个索引列, id FROM ... WHERE ...(同索引列条件) 也天然是覆盖索引。
* 覆盖索引的选择： 
创建覆盖索引有时需要将一些本不该出现在 WHERE 条件中的列加入到索引中（通常放在索引列的后面），以满足 SELECT 的需求。这是一种空间换时间的优化策略。需要权衡查询频率、性能提升与索引维护代价（写操作变慢、占用更多磁盘空间）。
* 最左前缀规则依然适用： 
覆盖索引本身仍然是索引，必须符合最左前缀规则才能被有效用于数据检索过滤。但它不要求覆盖索引的所有列都用于过滤，只要求需要的列在索引中存在（可以跳过索引前面列进行过滤，但这时如果不符合最左前缀规则，虽然能避免回表，但索引扫描本身可能也不是最优的）。


## 最左前缀原则 
MySQL索引遵循最左前缀原则（Leftmost Prefix Principle） 的核心原因在于其底层数据结构 B+树索引 的排序和存储方式。

### 有序存储
B+树索引是一种多路平衡搜索树，其叶子节点存储了实际的数据值（对于聚集索引是数据行，对于二级索引是主键值+索引列值），并且这些叶子节点通过指针相互连接，形成一个有序链表。

### 索引列的顺序至关重要： 
当创建一个联合索引（也叫复合索引）idx_col1_col2_col3 (col1, col2, col3) 时：
* 第一排序依据： 整个叶子节点中的数据首先严格按照 col1 的值进行排序。
* 第二排序依据： 在 col1 值相同的情况下，再按照 col2 的值进行排序。
* 第三排序依据： 在 col1 和 col2 的值都相同的情况下，最后才按照 col3 的值进行排序。

这种排序就像是字典的目录：
* 首先按第一个字母排序（相当于 col1）。
* 在第一个字母相同时，按第二个字母排序（相当于 col2）。
* 在第一个和第二个字母都相同时，按第三个字母排序（相当于 col3）。 


## 索引失效场景
### 1.索引列进行了运算或函数操作
如果对索引列进行了运算或使用了函数，MySQL无法使用索引，会导致索引失效。例如，对于以下查询语句：

SELECT * FROM table_name WHERE YEAR(date_column) = 2022;

如果date_column是索引列，但由于使用了YEAR函数，索引失效。

### 2. 使用了不匹配索引的LIKE查询：
当使用LIKE进行模糊查询时，如果通配符在开头，MySQL无法使用索引。 
例如，对于以下查询语句：

SELECT * FROM table_name WHERE column_name LIKE '%value%';

### 3.类型不匹配
当查询条件的数据类型与索引列的数据类型不匹配时，MySQL无法使用索引。例如，对于以下查询语句：

SELECT * FROM table_name WHERE int_column = 'value';

如果int_column是整数类型的索引列，但查询条件是字符串类型，会导致索引失效。

### 4.范围查询中的左前缀：
当查询条件包含范围操作符（如>, <, BETWEEN）时，“最左前缀”的匹配会提前终止：

例如，索引(a, b, c)，查询WHERE a>10 AND b=2 AND c=3：
* a>10会定位到a值大于10的所有叶子节点（这些节点在B+树中是连续的）；
* 但由于a的值不唯一（可能有多个不同的a值满足a>10），b和c仅在每个a的分组内有序，无法跨a分组保证顺序；
* 因此，只能利用a的范围定位，b和c需在匹配a>10的叶子节点中逐条扫描（无法使用索引优化b和c的条件）。

### 5.使用OR连接的条件
当查询条件中使用了OR连接多个条件时，如果其中有一个条件无法使用索引，整个查询可能会导致索引失效。例如，对于以下查询语句：

SELECT * FROM table_name WHERE indexed_column = 'value1' OR non_indexed_column = 'value2';
1
如果non_indexed_column未创建索引，整个查询可能会导致索引失效。

### 6. 索引列使用 is not null 查询。
